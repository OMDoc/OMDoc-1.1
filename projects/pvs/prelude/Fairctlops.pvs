%%% This file is automatically generated, from an OMDoc document 
%%% by an XSL style sheet (omdoc2xxx.xsl)  do not edit
%%% for information about OMDoc, see http://www.mathweb.org/omdoc


%%% The original omdoc with identifier `Fairctlops.omdoc`
%%% was created by: PVS (author)
%%% on: 2001-6-11@2:5:41 (created)

Fairctlops_test: THEORY
 BEGIN

  CheckFair: RECURSIVE funtype(pred,funtype(state,state,bool),pred,list,pred) = (lambda(Q: pred, N: funtype(state,state,bool), f: pred, Fflist: list):  CASES Fflist OF cons(Ff, Gflist):EU(N,f,(lambda(x1: state): AND(f(x1),(lambda(x: state): AND(Ff(x),EX(N,CheckFair(Q,N,f,Gflist))(x)))(x1)))), null: Q ENDCASES ) MEASURE length(Fflist);
  FairEG: funtype(funtype(state,state,bool),pred,funtype(list,pred)) = (lambda(N: funtype(state,state,bool), f: pred): (lambda(Fflist: list): nu((lambda(P: pred): CheckFair(P,N,f,Fflist)))));
  FairAF: funtype(funtype(state,state,bool),pred,funtype(list,pred)) = (lambda(N: funtype(state,state,bool), f: pred): (lambda(Fflist: list): (lambda(x1: state): NOT(FairEG(N,(lambda(x: state): NOT(f(x))))(Fflist)(x1)))));
  Fair?: funtype(funtype(state,state,bool),list,pred) = (lambda(N: funtype(state,state,bool), Fflist: list): FairEG(N,(lambda(u: state): TRUE))(Fflist));
  FairEX: funtype(funtype(state,state,bool),pred,funtype(list,pred)) = (lambda(N: funtype(state,state,bool), f: pred): (lambda(Fflist: list): EX(N,(lambda(x: state): AND(f(x),Fair?(N,Fflist)(x))))));
  FairEU: funtype(funtype(state,state,bool),pred,pred,funtype(list,pred)) = (lambda(N: funtype(state,state,bool), f: pred, g: pred): (lambda(Fflist: list): EU(N,f,(lambda(x: state): AND(g(x),Fair?(N,Fflist)(x))))));
  FairEF: funtype(funtype(state,state,bool),pred,funtype(list,pred)) = (lambda(N: funtype(state,state,bool), f: pred): (lambda(Fflist: list): EF(N,(lambda(x: state): AND(f(x),Fair?(N,Fflist)(x))))));
  FairAX: funtype(funtype(state,state,bool),pred,funtype(list,pred)) = (lambda(N: funtype(state,state,bool), f: pred): (lambda(Fflist: list): (lambda(x1: state): NOT(FairEX(N,(lambda(x: state): NOT(f(x))))(Fflist)(x1)))));
  FairAG: funtype(funtype(state,state,bool),pred,funtype(list,pred)) = (lambda(N: funtype(state,state,bool), f: pred): (lambda(Fflist: list): (lambda(x1: state): NOT(FairEF(N,(lambda(x: state): NOT(f(x))))(Fflist)(x1)))));
  FairAU: funtype(funtype(state,state,bool),pred,pred,funtype(list,pred)) = (lambda(N: funtype(state,state,bool), f: pred, g: pred): (lambda(Fflist: list): (lambda(x3: state): AND((lambda(x2: state): NOT(FairEU(N,(lambda(x: state): NOT(g(x))),(lambda(x1: state): AND((lambda(x: state): NOT(f(x)))(x1),(lambda(x: state): NOT(g(x)))(x1))))(Fflist)(x2)))(x3),FairAF(N,g)(Fflist)(x3)))));


 END Fairctlops_test



